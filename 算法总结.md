# 算法总结

- **二分查找**:

  ```python
  #二分查找
  l = [1,2,3,4,5,6]
  head = 0
  tail = len(l)
  while frist<last:
      mid = (frist+last)//2
    if target == l[mid]:
          break
      elif target>=l[mid]:
          frist = mid
      else:
          last = mid
      print(frist,last,mid)
  print(mid)
  ```
  
  

- **在一个无序数组上的搜索或者统计------O（1）时间复杂度的hash数据结构**

  ```
  l = [1,2,3,4,5,6]
  import collections
  hashmap = collections.defaultdict(int)
  for i in l:
      hashmap[i]+=1
  print(hashmap)
  ```

- **在一堆无序数中找top n ------使用最大堆或者最小堆的数据结构**

  - **二叉树性质**

    - 二叉树中，第 i 层最多有 2i-1 个结点。

    - 如果二叉树的深度为 K，那么此二叉树最多有 2K-1 个结点。

    - 二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则 n0=n2+1。

      (性质 3 的计算方法为：对于一个二叉树来说，除了度为 0 的叶子结点和度为 2 的结点，剩下的就是度为 1 的结点（设为 n1），那么总结点 n=n0+n1+n2。同时，对于每一个结点来说都是由其父结点分支表示的，假设树中分枝数为 B，那么总结点数 n=B+1。而分枝数是可以通过 n1 和 n2 表示的，即 B=n1+2*n2。所以，n 用另外一种方式表示为 n=n1+2*n2+1。两种方式得到的 n 值组成一个方程组，就可以得出 n0=n2+1.)

  - **满二叉树**

    如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树。

    ![满二叉树示意图](http://data.biancheng.net/uploads/allimg/181226/2-1Q226195949495.gif)

    满二叉树除了满足普通二叉树的性质，还具有以下性质：

    1. 满二叉树中第 i 层的节点数为 2n-1 个。
    2. 深度为 k 的满二叉树必有 2k-1 个节点 ，叶子数为 2k-1。
    3. 满二叉树中不存在度为 1 的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层。
    4. 具有 n 个节点的满二叉树的深度为 log2(n+1)。

  - **完全二叉树**

    ![完全二叉树示意图](http://data.biancheng.net/uploads/allimg/181226/2-1Q22620003J18.gif)
    完全二叉树除了具有普通二叉树的性质，它自身也具有一些独特的性质，比如说，n 个结点的完全二叉树的深度为 ⌊log2n⌋+1。

    对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号（如图 3a)），对于任意一个结点 i ，完全二叉树还有以下几个结论成立：

    1. 当 i>1 时，父亲结点为结点 [i/2] 。（i=1 时，表示的是根结点，无父亲结点）
    2. 如果 2*i>n（总结点的个数） ，则结点 i 肯定没有左孩子（为叶子结点）；否则其左孩子是结点 2*i 。
    3. 如果 2*i+1>n ，则结点 i 肯定没有右孩子；否则右孩子是结点 2*i+1 。

  - **堆**

    ```python
    import heapq
    data = [1,5,3,2,8,5]
    heap = []
    for n in data:
        heapq.heappush(heap, n)
    print(heap)
    #import heapq
    #data = [1,5,3,2,8,5]
    #heapq.heapify(data)
    #出堆
    #heapq.heappop(heap)
    ```

    堆排序循环删除堆顶元素

| 对象 | 使用的包                | 使用场景                                                     | 说明                 |
| ---- | :---------------------- | ------------------------------------------------------------ | -------------------- |
| 堆   | `heapq`                 | **单线程堆**                                                 | 最小堆               |
| 堆   | `queue.PriorityQueue`   | **并发环境使用的堆** 优先队列，用 `.put(x)` 和 `.get()` 实现入堆和出堆 | 最小堆               |
| 栈   | `deque`                 | **单线程栈** 通过 `.append(x)` 和 `.pop()` 实现压栈和出栈FILO |                      |
| 栈   | `queue.LifoQueue`       | **并发环境使用的栈** 通过 `.put(x)` 和 `.get()` 实现入栈和出栈 |                      |
| 队列 | `deque`                 | **单线程队列** 通过 `.append(x)` 和 `.popleft()` 实现入队和出队FIFO | 两头都可以插入和弹出 |
| 队列 | `queue.Queue`           | **并发环境使用的队列** 通过 `.put(x)` 和 `.get()` 实现入队和出队 |                      |
| 队列 | `multiprocessing.Queue` | **多进程环境使用的队列** 通过 `.put(x)` 和 `.get()` 实现入队和出队 |                      |



