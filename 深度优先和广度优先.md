# **深度优先和广度优先**

- **深度优先与广度优先实现**

```python
建立图的类
class tu():
    def __init__(self,val):
        self.val = val
        self.next = []
a = tu('A')
b = tu('B')
c = tu('C')
d = tu('D')
e = tu('E')
a.next.append(b)
a.next.append(d)
b.next.append(c)
d.next.append(b)
d.next.append(e)
e.next.append(c)
#深度优先利用栈的思想
def dfs(head):
    stack = [head]
    odd = []
    while stack:
        temp = stack.pop()
        odd.append(temp.val)
        for i in temp.next:
            stack.append(i)
    return odd
#递归版本深度优先
def ddfs(head):
    print(head.val)
    if head:
        for i in head.next:
            ddfs(i)
#广度优先利用队列的思想
def bfs(head):
    queue = [head]
    odd = []
    while queue:
        temp = queue.pop(0)
        odd.append(temp.val)
        for i in temp.next:
            queue.append(i)
    return odd
#print(ddfs(a))
```

## **例一**.

在给定的网格中，每个单元格可以有以下三个值之一：

值 0 代表空单元格；
值 1 代表新鲜橘子；
值 2 代表腐烂的橘子。
每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。

返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。

 

示例 1：



**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/oranges.png)**

```
输入：[[2,1,1],[1,1,0],[0,1,1]]
输出：4
```

```python
def orangesRotting(grid):
    M = len(grid)
    N = len(grid[0])
    queue = []

    count = 0  # count 表示新鲜橘子的数量
    for r in range(M):
        for c in range(N):
            if grid[r][c] == 1:
                count += 1
            elif grid[r][c] == 2:
                queue.append((r, c))

    round = 0  # round 表示腐烂的轮数，或者分钟数
    while count > 0 and len(queue) > 0:  # 还有好橘子且队列还有坏橘子
        round += 1  # 层数+1
        n = len(queue)  # 记录这一层的坏橘子数
        for i in range(n):  # 遍历完这一层的坏橘子
            r, c = queue.pop(0)  # 取出队列开头的坏橘子坐标
            if r-1 >= 0 and grid[r-1][c] == 1:  # 右邻有好橘子
                grid[r-1][c] = 2  # 好橘子变坏
                count -= 1  # 好橘子数-1
                queue.append((r-1, c))  # 新变坏的这只橘子进入坏橘子队列
            if r+1 < M and grid[r+1][c] == 1:  # 左邻有好橘子
                grid[r+1][c] = 2
                count -= 1
                queue.append((r+1, c))
            if c-1 >= 0 and grid[r][c-1] == 1:  # 下邻有好橘子
                grid[r][c-1] = 2
                count -= 1
                queue.append((r, c-1))
            if c+1 < N and grid[r][c+1] == 1:  # 上邻有好橘子
                grid[r][c+1] = 2
                count -= 1
                queue.append((r, c+1))

    if count > 0:  # 还有好橘子
        return -1
    else:  # 没有好橘子了
        return round
```

