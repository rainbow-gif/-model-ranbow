# **递归和回溯**

**递归与回溯的区别**

递归是一种算法结构。递归会出现在子程序中，形式上表现为直接或间接的自己调用自己。典型的例子是阶乘，计算规律为：n!=n×(n−1)!

回溯是一种算法思想，它是用递归实现的。回溯的过程类似于穷举法，但回溯有“剪枝”功能，即自我判断过程。例如有求和问题，给定有 7 个元素的组合 [1, 2, 3, 4, 5, 6, 7]，求加和为 7 的子集。累加计算中，选择 1+2+3+4 时，判断得到结果为 10 大于 7，那么后面的 5, 6, 7 就没有必要计算了。这种方法属于搜索过程中的优化，即“剪枝”功能。

 

用一个比较通俗的说法来解释递归和回溯：
我们在路上走着，前面是一个多岔路口，因为我们并不知道应该走哪条路，所以我们需要尝试。尝试的过程就是一个函数。
我们选择了一个方向，后来发现又有一个多岔路口，这时候又需要进行一次选择。所以我们需要在上一次尝试结果的基础上，再做一次尝试，即在函数内部再调用一次函数，这就是递归的过程。
这样重复了若干次之后，发现这次选择的这条路走不通，这时候我们知道我们上一个路口选错了，所以我们要回到上一个路口重新选择其他路，这就是回溯的思想。

**例一:**

给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

示例:

输入: n = 4, k = 2
输出:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]

```c++
#回溯模板
void backtracking(参数) {
 if (终⽌条件) {
 存放结果;
 return;
 }
 for (选择：本层集合中元素（树中节点孩⼦的数量就是集合的⼤⼩）) {
 处理节点;
 backtracking(路径，选择列表); // 递归
 回溯，撤销处理结果
 }
}
```

```python
n,k = 4,2
res = []
def backtracking(i,temp):
    if len(temp)==k:
        res.append(temp[:])
    for j in range(i,n):
        backtracking(j+1,temp+[j])
backtracking(1,[])
print(res)
```

**例二:**

找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复

的数字。

说明：

​	所有数字都是正整数。

​	解集不能包含重复的组合。

示例 1:

输⼊: k = 3, n = 7

输出: [[1,2,4]]

示例 2:

输⼊: k = 3, n = 9

输出: [[1,2,6], [1,3,5], [2,3,4]]

```python
k = 3, n = 7
res = []
def backtracking(i,temp):
    if len(temp) == k and sum(temp)==n:
        res.append(temp[:])
        return
    if len(temp) >= k or sum(temp)>n:
        return  
    for j in range(i,n-(k-len(res))+2):
        if j<=9:
            backtracking(j+1,temp+[j])
backtracking(1,[])
print(res)
```



**例三:**

给定⼀个仅包含数字 2-9 的字符串，返回所有它能表示的字⺟组合。

给出数字到字⺟的映射如下（与电话按键相同）。注意 1 不对应任何字⺟。

<img src="C:\Users\BCM004\AppData\Roaming\Typora\typora-user-images\image-20210422151102512.png" alt="image-20210422151102512" style="zoom:33%;" />

示例:

输⼊："23"

输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].

说明：尽管上⾯的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。

```python
digits = '23'
d = [i for i in range(2, 7)]
w = [chr(i) for i in range(97, 123)]
w = [w[i*3:(i+1)*3] for i in range(5)]

dic = {k: v for k,v in zip(d,w)}
dic[7] = ['p','q','r','s']
dic[8] = ['t','u','v']
dic[9] = ['w','x','y','z']
res = []
def backtracking(i,temp):
    if len(temp) == len(digits):
        res.append(temp[:])
        return

    for j in dic[int(digits[i])]:
        backtracking(i+1,temp+j)
backtracking(0,'')
print(res)
```

**例四:**

给定⼀个⽆重复元素的数组 candidates 和⼀个⽬标数 target ，找出 candidates 中所有可以使数字和为

target 的组合。

candidates 中的数字可以⽆限制重复被选取。

说明：

所有数字（包括 target）都是正整数。

解集不能包含重复的组合。

示例 1：

输⼊：candidates = [2,3,6,7], target = 7,

所求解集为：

[

 [7],

 [2,2,3]

]

示例 2：

输⼊：candidates = [2,3,5], target = 8,

所求解集为：

[ [2,2,2,2],

 [2,3,3],

 [3,5]

]

```python
candidates = [2,3,5]
target = 8
res = []
def backtracking(temp):
    if sum(temp) == target and sorted(temp) not in res:
        res.append(sorted(temp))
        return 
    if sum(temp) > target:
        return
    for j in range(0,len(candidates)):
        backtracking(temp+[candidates[j]])
backtracking([])
print(res)
```

**例五:**

给定⼀个数组 candidates 和⼀个⽬标数 target ，找出 candidates 中所有可以使数字和为 target 的组

合。

candidates 中的每个数字在每个组合中只能使⽤⼀次。

说明：

所有数字（包括⽬标数）都是正整数。

解集不能包含重复的组合。

示例 1:

输⼊: candidates = [10,1,2,7,6,1,5], target = 8,

所求解集为: 

[

 [1, 7],

 [1, 2, 5],

 [2, 6],

 [1, 1, 6]

]示例 2:

输⼊: candidates = [2,5,2,1,2], target = 5,

所求解集为: 

[

 [1,2,2],

 [5]

]

```python
candidates = [2,5,2,1,2]
target = 5
candidates.sort()
res = []
def backtracking(i,temp):
    if sum(temp) == target:
        res.append(temp[:])
        return
    for j in range(i,len(candidates)):
        if sum(temp)>target:
            break
        if i<j and candidates[j] == candidates[j-1]:
            continue
        backtracking(j+1,temp+[candidates[j]])
backtracking(0,[])
print(res)
```

**例六:**

给定⼀个字符串 s，将 s 分割成⼀些⼦串，使每个⼦串都是回⽂串。

返回 s 所有可能的分割⽅案。

示例:

输⼊: "aab"

输出: 

[

 ["aa","b"],

 ["a","a","b"]

]

```python
是= 'aab'
res = []
ans = []
def backtracking(s):
    if len(s) == 0:res.append(ans[:])
    for i in range(1,len(s)+1):
        if s[0:i] == s[i-1::-1]:
            ans.append(s[0:i])
            backtracking(s[i:])
            ans.pop()
backtracking(s)
print(res)
```

