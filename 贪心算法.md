# **贪心算法**

#### **什么是贪⼼**

**贪⼼的本质是选择每⼀阶段的局部最优，从⽽达到全局最优**。

这么说有点抽象，来举⼀个例⼦：

例如，有⼀堆钞票，你可以拿⾛⼗张，如果想达到最⼤的⾦额，你要怎么拿？

指定每次拿最⼤的，最终结果就是拿⾛最⼤数额的钱。

每次拿最⼤的就是局部最优，最后拿⾛最⼤数额的钱就是推出全局最优。

再举⼀个例⼦如果是 有⼀堆盒⼦，你有⼀个背包体积为n，如何把背包尽可能装满，如果还每次选最⼤

的盒⼦，就不⾏了。这时候就需要动态规划。动态规划的问题在下⼀个系列会详细讲解。

**1. 贪⼼很简单，就是常识？**

**跟着⼀起刷题的录友们就会发现，贪⼼思路往往很巧妙，并不简单。**

**2. 贪⼼有没有固定的套路？**

**贪⼼⽆套路，也没有框架之类的，需要多看多练培养感觉才能想到贪⼼的思路。**

**3. 究竟什么题⽬是贪⼼呢？**

**个⼈认为：如果找出局部最优并可以推出全局最优，就是贪⼼，如果局部最优都没找出来，就不是**

**贪⼼，可能是单纯的模拟。（并不是权威解读，⼀家之辞哈）**

**但我们也不⽤过于强调什么题⽬是贪⼼，什么不是贪⼼，那就太学术了，毕竟学会解题就⾏了。**

**4. 如何知道局部最优推出全局最优，有数学证明么？没有数学证明感觉不靠谱？**

**在做贪⼼题的过程中，如果再来⼀个数据证明，其实没有必要！⼿动模拟⼀下，如果找不出反例，就试**

**试贪⼼。⾯试中，代码写出来跑过测试⽤例即可，或者⾃⼰能⾃圆其说理由就⾏了。**

**在对于贪⼼问题，很多同学是两个极端：左极端，右极端。**

**左极端：就是遇到问题就要数学证明，没有数学证明就感觉不靠谱，但⾃⼰最终花费了⼤量的时间还是**

**证明不出来。**

**右极端：贪⼼很简单，就是常识，很⾃然就是这么做，但⼀些题⽬⼀旦超出常识的思考范围了，就毫⽆**

**思路了。**

**⽽在讲解贪⼼的时候，既有简单适当的证明（每篇⽂章都⽤了反证法），也把常识性的知识理论**

**化，系统化（局部最优、全局最优的分析）。**

**说了这么多，还是眼⻅为⽌，⼤家开始学习贪⼼算法吧！**

**例一:455.分发饼干**

假设你是⼀位很棒的家⻓，想要给你的孩⼦们⼀些⼩饼⼲。但是，每个孩⼦最多只能给⼀块饼⼲。

对每个孩⼦ i，都有⼀个胃⼝值 g[i]，这是能让孩⼦们满⾜胃⼝的饼⼲的最⼩尺⼨；并且每块饼⼲ j，都

有⼀个尺⼨ s[j] 。如果 s[j] >= g[i]，我们可以将这个饼⼲ j 分配给孩⼦ i ，这个孩⼦会得到满⾜。你的⽬

标是尽可能满⾜越多数量的孩⼦，并输出这个最⼤数值。示例 1:

输⼊: g = [1,2,3], s = [1,1]

输出: 1

解释:

你有三个孩⼦和两块⼩饼⼲，3个孩⼦的胃⼝值分别是：1,2,3。

虽然你有两块⼩饼⼲，由于他们的尺⼨都是1，你只能让胃⼝值是1的孩⼦满⾜。

所以你应该输出1。

示例 2:

输⼊: g = [1,2], s = [1,2,3]

输出: 2

解释:

你有两个孩⼦和三块⼩饼⼲，2个孩⼦的胃⼝值分别是1,2。

你拥有的饼⼲数量和尺⼨都⾜以让所有孩⼦满⾜。

所以你应该输出2.

**解题思路:**

饼干和孩子胃口,排序之后相比较,要是能够喂饱结果加一,否则让下一个孩子尝试.

```python
g,s=[1,2],[1,2,3]
lenchr = len(g)-1
lens = len(s)-1
g.sort()
s.sort()
res = 0
while lenchr >=0 and lens>=0:
    if g[lenchr] <= s[lens]:
        res+=1
        lenchr-=1
        lens-=1
    else:
        lenchr-=1
print(res)
```

**例二:376.摆动排序**

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第⼀个差（如果存在

的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如， [1,7,4,9,2,5] 是⼀个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反,

[1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第⼀个序列是因为它的前两个差值都是正数，第⼆个序列是因

为它的最后⼀个差值为零。

给定⼀个整数序列，返回作为摆动序列的最⻓⼦序列的⻓度。 通过从原始序列中删除⼀些（也可以不删

除）元素来获得⼦序列，剩下的元素保持其原始顺序。

示例 1:

输⼊: [1,7,4,9,2,5]

输出: 6

解释: 整个序列均为摆动序列。



**解题思路:**

第一种方式找峰值,第二种删除山腰的值

```python
def maxlen(nums):
    if len(set(nums))==1:return 1
    for i in range(len(nums)-2,0,-1):
        if (nums[i]-nums[i-1])*(nums[i+1]-nums[i])>=0://判断是否在山腰
            nums.pop(i)
    return len(nums)
```

**例三:53.** **最⼤⼦序和**

给定⼀个整数数组 nums ，找到⼀个具有最⼤和的连续⼦数组（⼦数组最少包含⼀个元素），返回其最

⼤和。示例:

输⼊: [-2,1,-3,4,-1,2,1,-5,4]

输出: 6

解释: 连续⼦数组 [4,-1,2,1] 的和最⼤，为 6。





**解题思路**:

如果 -2 1 在⼀起，计算起点的时候，⼀定是从1开始计算，因为负数只会拉低总和，这就是贪⼼贪的地

⽅！

局部最优：当前“连续和”为负数的时候⽴刻放弃，从下⼀个元素重新计算“连续和”，因为负数加上下⼀个

元素 “连续和”只会越来越⼩。

全局最优：选取最⼤“连续和”

**局部最优的情况下，并记录最⼤的****“****连续和****”****，可以推出全局最优**。

从代码⻆度上来讲：遍历nums，从头开始⽤count累积，如果count⼀旦加上nums[i]变为负数，那么就

应该从nums[i+1]开始从0累积count了，因为已经变为负数的count，只会拖累总和。

**这相当于是暴⼒解法中的不断调整最⼤⼦序和区间的起始位置**。

```python
#贪心写法
def maxsum(nums)
	res ,count= -float('inf'),0
    for i in range(len(nums))
        count+=nums[i]
        if count>res:
            res = count
        if count<0:
            count = 0
    return res
```



```python
#动态规划写法
def maxsum(nums)
	res = []#建立dp列表
    for i in range(len(nums)):
        if i==0:
            res.append(nums[i])
        else:
            temp = nums[i]+res[-1]
            if temp>0:
                res.append(max(nums[i],temp))
            else:
                res.append(max(nums[i],temp))
    return max(res)
```

**例题四:122.买卖股票的最佳时机II**

给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

示例 1:

输入: prices = [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
示例 2:

输入: prices = [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
示例 3:

输入: prices = [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。



**解题思路:**

根据题意当天卖出之后能当天买进股票,所以把所有能单次获得的利润相加就是答案

```python
def maxprofix(prices):
	res = 0
    for i in range(len(prices)-1):
        if prices[i]<prices[i+1]:
            res += prices[i+1]-prices[i]
    return res
```





**例题五:55.** **跳跃游戏**

给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

 

示例 1：

输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
示例 2：

输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。



**解题思路:**

只要求每次跳跃的覆盖区域就行,看最后的覆盖区域是不是能够到达最后一个下标,而且当覆盖区域小于当前区域的话直接返回False

```python
#回溯法
res = False
def backtracking(now,nums,index):
    globle res
    #print(index)
    if index==1:
        res = True
    for i in range(1,nums[now]+1):
        if index>0 and now+i<len(nums) and not res:
            backtracking(now+i,nums,index-i)
backtracking(0,nums,len(nums))

print(res)
```

```python
#贪心算法
def canjump(nums)
    maxpos = 0
    for i in range(len(nums)):
        if i<=maxpos:
            maxpos = max(maxpos,nums[i]+i)
            if maxpos>=len(nums)-1:
                return True
        else:
            return False
```



**例题六:45.跳跃游戏II**



给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

假设你总是可以到达数组的最后一个位置。

 

示例 1:

输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
示例 2:

输入: [2,3,0,1,4]
输出: 2

**解题思路:**

只要求每次跳跃的覆盖区域就行,看最后的覆盖区域是不是能够到达最后一个下标,而且当覆盖区域小于当前区域的话直接返回False,只不过这次是求跳跃的最小次数,所以把当前覆盖区域里的元素都找一遍选出能覆盖最远的区域,重置最远maxpos,跳跃次数加一

```python
def canjump(nums):
    maxpos = 0
    temp = 0
    res = 0
    if len(nums) ==1:
        return 0
    for i in range(len(nums)):
        if i<=maxpos:
            if nums[i]+i>maxpos:
                temp = max(temp,nums[i]+i)
            if i == maxpos:
                maxpos = temp
                res+=1
            if maxpos>=len(nums)-1:
                return res
        else:
            return False
```





**例题七:1005.K次取反后最⼤化的数组和**

给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）

以这种方式修改数组后，返回数组可能的最大和。

 

示例 1：

输入：A = [4,2,3], K = 1
输出：5
解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。
示例 2：

输入：A = [3,-1,0,2], K = 3
输出：6
解释：选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。
示例 3：

输入：A = [2,-3,-1,5,-4], K = 2
输出：13
解释：选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。



**解题思路:**

推荐使用python的内置堆heapify(目标列表)创建堆,heappush(堆,元素)--元素入堆,heappop(堆)--元素出堆.循环k次每次最小值出堆然后取反入堆就能解决问题.

```python
import heapq
def maxsum(A,K): 
    heapq.heapify(A)
    for _ in range(K):
        temp = -heapq.heappop(A)
        heapq.heappush(A,temp)
    return sum(A)
```







**例题八:134.** **加油站**

	在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。

说明: 

如果题目有解，该答案即为唯一答案。
输入数组均为非空数组，且长度相同。
输入数组中的元素均为非负数。
示例 1:

```
输入: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

输出: 3

解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。
```

**解题思路:**

汽油和消耗汽油的差如果为负数直接试探下一个起点,要是所有点累计汽油都没有出现负数的情况说明从此起点出发能够行驶一圈

```python
def cancircle(gas,cost):
    count = 0
    for i in range(len(gas)):
        tempgas = gas[i:]+gas[:i]
        tempcost = cost[i:]+cost[:i]
        for j in range(len(tempcost)):
            count += tempgas[j]-tempcost[j]
            if count < 0:
                count=0
                break
        else:
            return i
    return -1
```



**例题九:135.** **分发糖果**

老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。

你需要按照以下要求，帮助老师给这些孩子分发糖果：

每个孩子至少分配到 1 个糖果。
评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。
那么这样下来，老师至少需要准备多少颗糖果呢？

 

示例 1：

```
输入：[1,0,2]
输出：5
解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。

```

示例 2：

```
输入：[1,2,2]
输出：4
解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。
```





**解题思路:**

假设A在B的左边

设计的算法必须满足两个规则:

左规则:A<B时 B的糖果要比A多

右规则:A>B时 A的糖果要比B多

![img](https://pic.leetcode-cn.com/164a4bae4eacfcbd0d5bad0aaf11f215fb2847470f6cb1d5eaca2d8b13c1dc61-Picture10.png)





```python
 def candy(ratings):
    right = [1 for _ in range(len(ratings))]
    left = right[:]
    res = 0
    for i in range(1,len(ratings)):
        if ratings[i]>ratings[i-1]:
            left[i] = left[i-1]+1
    for i in range(len(ratings)-2,-1,-1):
        if ratings[i]>ratings[i+1]:
            right[i] = right[i+1]+1

    return sum([max(i) for i in zip(right,left)])
```





**例题十:860.柠檬⽔找零**

在柠檬水摊上，每一杯柠檬水的售价为 5 美元。

顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。

注意，一开始你手头没有任何零钱。

如果你能给每位顾客正确找零，返回 true ，否则返回 false 。

示例 1：

```
输入：[5,5,5,10,20]
输出：true
解释：
前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
由于所有客户都得到了正确的找零，所以我们输出 true。
```


示例 2：

输入：[5,5,10]
输出：true
示例 3：

```
输入：[10,10]
输出：false
```


示例 4：

```
输入：[5,5,10,10,20]
输出：false
解释：
前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。
对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。
对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。
由于不是每位顾客都得到了正确的找零，所以答案是 false。
```



**解题思路:**

情况⼀：账单是5，直接收下。

情况⼆：账单是10，消耗⼀个5，增加⼀个10

情况三：账单是20，优先消耗⼀个10和⼀个5，如果不够，再消耗三个5
$$

$$

```python
def bill(bills):
	five = 0
    ten = 0
    for i in bills:
        if i == 5:
            five+=1
        elif i == 10:
            five-=1
            ten+=1
        else:
            if ten>0:
                ten-=1
                five-=1
            else:
                five-=3
        if five <0 or ten<0:
            return False
    return True
```







#### **例题十一:406.****根据身⾼重建队列**



假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。

请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。

 

示例 1：

```
输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
```

示例 2：

```
输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
```

**解题思路:**

把队列优先按照升高由高到低排列,如果身高相同就按照前面有 多少个元素从小到大 排列,然后再进行遍历插入排序进入新列表

```python
def requeue(people):
    people.sort(key = lambda x:(-x[0],x[1]))
    res = []
    for i in people:
        res.insert(i[1],i)
    return res
```





**例题十二:452.** **⽤最少数量的箭引爆⽓球**



在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。

一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。

给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。


示例 1：

```
输入：points = [[10,16],[2,8],[1,6],[7,12]]
输出：2
```


解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球
示例 2：

```
输入：points = [[1,2],[3,4],[5,6],[7,8]]
输出：4
```



**解题思路:**

排序前

![fig1](https://assets.leetcode-cn.com/solution-static/452/1.png)

排序之后

```
标杆
[1.......6] 
   [2..........8] 
            [7.........12] 
                   [10.........16]
```

找到第一个重合区间 和第二个重合区间的分割点,使得弓箭数量加一.记得维持最小右边界

```python
def minarrow(points):
    res = 1
    points.sort(key = lambda x:x[0])
    for i in range(1,len(points)):
        if points[i][0]>points[i-1][1]:
            res+=1
        else:
            points[i][1] = min(points[i][1],points[i-1][1])
    return res
```







**例题十三:435.** **⽆重叠区间**

给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

注意:

可以认为区间的终点总是大于它的起点。
区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。
示例 1:

输入: [ [1,2], [2,3], [3,4], [1,3] ]

输出: 1

解释: 移除 [1,3] 后，剩下的区间没有重叠。
示例 2:

输入: [ [1,2], [1,2], [1,2] ]

输出: 2

解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
示例 3:

输入: [ [1,2], [2,3] ]

输出: 0

解释: 你不需要移除任何区间，因为它们已经是无重叠的了。



**解题思路:**

例题十二是找无重合区间,无重合区间需要删除的元素个数就是,数组的长度减去无重合区间的长度.

记得处理边界的问题

```python
def minremove(intervals):
    res = 1
    intervals.sort(key = lambda x:x[0])
    for i in range(1,len(intervals)):
        if intervals[i][0]>=intervals[i-1][1]:
            res+=1
        else:
            intervals[i][1] = min(intervals[i][1],intervals[i-1][1])
    return len(intervals)-res
```



**例题十四:763.****划分字⺟区间**

字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。

 

示例：

输入：S = "ababcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca", "defegde", "hijhklij"。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。



**解题思路:**

从左到右遍历 维护start 和 end变量 ,使用nowchr记录当前字符,内层循环搜寻和nowchr相等的字符位置为j,更新end = max(end,j).当外层循环遍到end的时候说明第一个区间产生.记录区间长度end-start+1. 更新start ,end = i+1,i+1.



```python
def partlable(S):
	start ,end = 0,0
    res = []
    for i in range(len(S)):
        nowchr = S[i]
        for j in range(i,len(S)):
            if nowchr == S[j]:
                end = max(end,j)            
        if i == end:
            res.append(end-start+1)
            start ,end = i+1,i+1
    return res
```





**例题十五:56.** **合并区间**

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

 

示例 1：

输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
示例 2：

输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。



**解题思路:**

注意此题需考虑排序之后遍历列表 维护左边界的最小值,右边界的最大值 当下一个元素的左边界大于目前的右边界,添加结果.否则维护左边界和右边界



```python
def merge(intervals):
        if len(intervals)==1:return intervals
        intervals.sort(key = lambda x:x[0])
        res = []
        for i in range(1,len(intervals)):
            if intervals[i][0]>intervals[i-1][1]:
                res.append([intervals[i-1][0],intervals[i-1][1]])
            else:
                intervals[i][0] = intervals[i-1][0]
                intervals[i][1] = max(intervals[i-1][1],intervals[i][1])

        res.append([intervals[i][0],intervals[i][1]])
        return res
```





**例题十六:738.****单调递增的数字**

给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。

（当且仅当每个相邻位数上的数字 x 和 y 满足 x <= y 时，我们称这个整数是单调递增的。）

示例 1:

输入: N = 10
输出: 9
示例 2:

输入: N = 1234
输出: 1234
示例 3:

输入: N = 332
输出: 299

**解题思路:**

找到第一个不符合递增的元素,使得此数改成0然后补位减一 ,一直重复操作直到数字是一个完全的递增数,返回s



```python
def increasing(N):
    if len(str(N)) == 1:
    return N
    s = str(N)
    res = ''
    while True:
        for i in range(1,len(s)):
            if int(s[i])<int(s[i-1]):
                res = s[:i]
                break
        else:
            return int(s)
        res+='0'*(len(s)-len(res))
        s = str(int(res)-1)
        res = ''
```









**例题十七:714.买卖股票的最佳时机含⼿续费**

给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

示例 1:

```
输入: prices = [1, 3, 2, 8, 4, 9], fee = 2
输出: 8
解释: 能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
```

**解题思路:**

关键在于判断是否连续涨,curr变量在每次卖出的时候都赋值当前元素的值而不是归零.这样就能抵消连续涨的手续费,相当于连续涨的时候没有出手续费没有操作.

```python
def maxporfit(prices):
	n = len(prices)
    porfit = 0
    curr = prices[0]+fee
    for i in range(1,n):
        if curr>prices[i]+fee:
            curr = prices[i]+fee
        elif prices[i]>curr:
            porfit+=prices[i]-curr
            curr =prices[i]
    return porfit
```

